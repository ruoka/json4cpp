// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.
module;

export module xson:json;

import std;
import :object;

export namespace xson::json {

using object = xson::object;

class encoder
{
public:

    // Default indentation level for pretty-printed JSON
    static constexpr std::streamsize default_indent = 2;

    encoder(std::streamsize indent = default_indent) : m_pretty{indent}
    {}

    void encode(std::ostream& os, const object& o)
    {
        if(o.is_object())
        {
            const auto& container = o.get<object::map>();
            os << m_pretty('{');
            for(auto i = 0; const auto& [name,value] : container)
            {
                os << (i++ == 0 ? m_pretty() : m_pretty(','));
                os << '\"' << name << '\"' << m_pretty(':');
                encode(os,value);
            }
            os << m_pretty('}', container.empty());
        }
        else if(o.is_array())
        {
            const auto& container = o.get<object::array>();
            os << m_pretty('[');
            for(auto i = 0; const auto& value : container)
            {
                os << (i++ == 0 ? m_pretty() : m_pretty(','));
                encode(os,value);
            }
            os << m_pretty(']', container.empty());
        }
        else
            os << o.get<object::value>();
    }

private:

    class prettyprint
    {
    public:

        prettyprint(std::streamsize indent) : m_indent{indent}, m_level{0}
        {}

        std::string operator () ()
        {
            if(!m_indent)
                return ""s;
            else
                return "\n"s + m_pretty;
        }

        std::string operator () (char c, bool empty = false)
        {
            if(!m_indent)
                return std::string{c};

            if(c == ':')
                return " : "s;

            if(c == ',')
                return  ",\n"s + m_pretty;

            if(c == '{' || c == '[')
            {
                ++m_level;
                m_pretty = std::string(m_level * m_indent, ' ');
                return std::string{c};
            }

            if(c == '}' || c == ']')
            {
                --m_level;
                m_pretty = std::string(m_level * m_indent, ' ');
                if(!empty)
                    return  "\n"s + m_pretty + c;
                else
                    return std::string{c};
            }

            return std::string{c};
        }

        friend std::ostream& operator << (std::ostream& os, const prettyprint& p)
        {
            os << p.m_pretty;
            return os;
        }

    private:

        std::streamsize m_indent;

        std::streamsize m_level;

        std::string m_pretty;
    };

    prettyprint m_pretty;
};

// Decoder implementation
template<typename Builder>
class decoder
{
public:

    decoder(Builder& b) : m_builder{b}
    {}

    void decode(std::istream& is)
    {
        m_state_machine.push(&decoder::document);
        while(is.good())
        {
            auto c = is.get();
            if(is.eof())
                break;
            if(is.fail())
                throw std::runtime_error{"Stream error while reading JSON input"};
            m_state_machine.top()(*this, static_cast<char>(c));
            if(m_state_machine.empty()) break;
        }
        if(!m_state_machine.empty())
            throw std::runtime_error{"Invalid JSON: incomplete document (unexpected end of input)"s};
    }

    void decode(std::string_view sv)
    {
        m_state_machine.push(&decoder::document);
        for(auto c : sv)
        {
            m_state_machine.top()(*this,c);
            if(m_state_machine.empty()) break;
        }
        if(!m_state_machine.empty())
            throw std::runtime_error{"Invalid JSON: incomplete document (unexpected end of string)"s};
    }

private:

    template <bool Boolean>
    void constant(char c)
    {
        m_builder.value(Boolean);
        m_state_machine.pop();
        m_state_machine.top()(*this,c);
    }

    void null(char c)
    {
        m_builder.value(nullptr);
        m_state_machine.pop();
        m_state_machine.top()(*this,c);
    }

    template <char Character>
    void is(char c)
    {
        if(c == Character)
            m_state_machine.pop();
        else
            throw std::runtime_error{"JSON parse error: expected '"s + std::string{Character} + "', got '"s + c + "'"s};
    }

    void string(char c)
    {
        if(c == '\\')
        {
            m_state_machine.push(&decoder::escape);
        }
        else if(c != '\"')
        {
            m_string += c;
        }
        else
        {
            m_builder.value(std::move(m_string));
            m_state_machine.pop();
            m_string = ""s;
        }
    }

    void escape(char c)
    {
        m_state_machine.pop();
        switch(c)
        {
            case '\"': m_string += '\"'; break;
            case '\\': m_string += '\\'; break;
            case '/':  m_string += '/'; break;
            case 'b':  m_string += '\b'; break;
            case 'f':  m_string += '\f'; break;
            case 'n':  m_string += '\n'; break;
            case 'r':  m_string += '\r'; break;
            case 't':  m_string += '\t'; break;
            case 'u':
                m_state_machine.push(&decoder::unicode_escape);
                m_unicode_value = 0;
                m_unicode_digits = 0;
                break;
            default:
                throw std::runtime_error{"Invalid escape sequence: \\"s + c};
        }
    }

    void unicode_escape(char c)
    {
        if(std::isxdigit(c))
        {
            m_unicode_value *= 16;
            if(std::isdigit(c))
                m_unicode_value += (c - '0');
            else if(c >= 'a' && c <= 'f')
                m_unicode_value += (c - 'a' + 10);
            else if(c >= 'A' && c <= 'F')
                m_unicode_value += (c - 'A' + 10);
            
            ++m_unicode_digits;
            if(m_unicode_digits == 4)
            {
                if(m_unicode_value <= 0x7F)
                {
                    m_string += static_cast<char>(m_unicode_value);
                }
                else if(m_unicode_value <= 0x7FF)
                {
                    m_string += static_cast<char>(0xC0 | (m_unicode_value >> 6));
                    m_string += static_cast<char>(0x80 | (m_unicode_value & 0x3F));
                }
                else
                {
                    m_string += static_cast<char>(0xE0 | (m_unicode_value >> 12));
                    m_string += static_cast<char>(0x80 | ((m_unicode_value >> 6) & 0x3F));
                    m_string += static_cast<char>(0x80 | (m_unicode_value & 0x3F));
                }
                m_state_machine.pop();
                m_unicode_value = 0;
                m_unicode_digits = 0;
            }
        }
        else
        {
            throw std::runtime_error{"Invalid Unicode escape sequence: expected hex digit, got "s + c};
        }
    }

    template<int Sign>
    void number(char c)
    {
        if(std::isdigit(c))
        {
            m_integer *= 10;
            m_integer += (c-'0');
        }
        else if(c == '.')
        {
            m_number = m_integer;
            m_integer = 0;
            m_state_machine.pop();
            m_state_machine.push(&decoder::fractions<Sign>);
        }
        else
        {
            m_builder.value(Sign * m_integer);
            m_integer = 0;
            m_state_machine.pop();
            m_state_machine.top()(*this,c);
        }
    }

    template<int Sign>
    void fractions(char c)
    {
        if(std::isdigit(c))
        {
            m_place *= 10;
            m_number += (static_cast<xson::number_type>(c-'0')/m_place);
        }
        else
        {
            m_builder.value(Sign * m_number);
            m_number = 0;
            m_place = 1;
            m_state_machine.pop();
            m_state_machine.top()(*this,c);
        }
    }

    void positive(char c) {return number<1>(c);}

    void negative(char c) {return number<-1>(c);}

    void value(char c)
    {
        if(c == '\"')
        {
            m_state_machine.push(&decoder::string);
        }
        else if(std::isdigit(c))
        {
            m_state_machine.push(&decoder::positive);
            m_state_machine.top()(*this,c);
        }
        else if(c == '-')
        {
            m_state_machine.push(&decoder::negative);
        }
        else if(c == 't')
        {
            m_state_machine.push(&decoder::constant<true>);
            m_state_machine.push(&decoder::is<'e'>);
            m_state_machine.push(&decoder::is<'u'>);
            m_state_machine.push(&decoder::is<'r'>);
        }
        else if(c == 'f')
        {
            m_state_machine.push(&decoder::constant<false>);
            m_state_machine.push(&decoder::is<'e'>);
            m_state_machine.push(&decoder::is<'s'>);
            m_state_machine.push(&decoder::is<'l'>);
            m_state_machine.push(&decoder::is<'a'>);
        }
        else if(c == 'n')
        {
            m_state_machine.push(&decoder::null);
            m_state_machine.push(&decoder::is<'l'>);
            m_state_machine.push(&decoder::is<'l'>);
            m_state_machine.push(&decoder::is<'u'>);
        }
        else if(c == '{' || c == '[')
        {
            m_state_machine.push(&decoder::document);
            m_state_machine.top()(*this,c);
        }
        else if (c == ',' || c == '}' || c == ']')
        {
            m_state_machine.pop();
            m_state_machine.top()(*this,c);
        }
        else if(!isws(c))
            throw std::runtime_error{"JSON parse error: unexpected character in value context: '"s + c + "' (0x"s + std::to_string(static_cast<unsigned char>(c)) + ")"s};
    }

    void comma(char c)
    {
        if(c == ',')
        {
            m_state_machine.pop();
        }
        else if(c == '}' || c == ']')
        {
            m_state_machine.pop();
            m_state_machine.top()(*this,c);
        }
        else if(!isws(c))
            throw std::runtime_error{"JSON parse error: expected comma, '}' or ']', got '"s + c + "'"s};
    }

    void colon(char c)
    {
        if(c == ':')
            m_state_machine.pop();
        else if(!isws(c))
            throw std::runtime_error{"JSON parse error: expected colon ':', got '"s + c + "'"s};
    }

    void name(char c)
    {
        if(c != '\"')
            m_string += c;
        else
        {
            m_builder.name(m_string);
            m_string = ""s;
            m_state_machine.pop();
        }
    }

    void object(char c)
    {
        if(c == '}')
        {
            m_state_machine.pop();
            m_state_machine.top()(*this,c);
        }
        else if(c == '\"')
        {
            m_state_machine.push(&decoder::comma);
            m_state_machine.push(&decoder::value);
            m_state_machine.push(&decoder::colon);
            m_state_machine.push(&decoder::name);
        }
        else if(!isws(c))
            throw std::runtime_error{"JSON parse error: unexpected character in object context: '"s + c + "'"s};
    }

    struct array
    {
        void operator()(decoder& p, char c)
        {
            if(c == ']')
            {
                p.m_state_machine.pop();
                p.m_state_machine.top()(p,c);
            }
            else if (c != ',' && c != '}')
            {
                p.m_state_machine.push(&decoder::comma);
                p.m_state_machine.push(&decoder::value);
                p.m_state_machine.top()(p,c);
            }
            else if(!isws(c))
                throw std::runtime_error{"JSON parse error: unexpected character in array context: '"s + c + "'"s};

        }
    };

    void document(char c)
    {
        if(c == '{')
        {
            m_builder.start_object();
            m_state_machine.push(&decoder::object);
        }
        else if(c == '}')
        {
            m_builder.end_object();
            m_state_machine.pop();
        }
        else if(c == '[')
        {
            m_builder.start_array();
            m_state_machine.push(array{});
        }
        else if(c == ']')
        {
            m_builder.end_array();
            m_state_machine.pop();
        }
        else if(!isws(c))
            throw std::runtime_error{"JSON parse error: unexpected character at document start: '"s + c + "'"s};
    }

    static bool isws(char c)
    {
        return (std::isblank(c) || std::iscntrl(c));
    }

    using state = std::function<void(decoder&,char)>;

    std::stack<state> m_state_machine = std::stack<state>{};

    Builder& m_builder;

    xson::string_type m_string = ""s;

    xson::integer_type m_integer = 0;

    xson::number_type m_number = 0;

    xson::integer_type m_place = 1;

    std::uint32_t m_unicode_value = 0;
    int m_unicode_digits = 0;

}; // class decoder

// Public API functions
inline object parse(std::istream& is)
{
    auto b = xson::builder{};
    auto d = decoder<xson::builder>{b};
    d.decode(is);
    return b.get();
}

inline object parse(std::string_view sv)
{
    auto b = xson::builder{};
    auto d = decoder<xson::builder>{b};
    d.decode(sv);
    return b.get();
}

// Convert object to JSON string with optional pretty-printing
// @param ob Object to stringify
// @param indent Indentation level (0 = compact, >0 = pretty-printed)
// @return JSON string representation
inline std::string stringify(const object& ob, unsigned indent = encoder::default_indent)
{
    auto ss = std::stringstream{};
    encoder{indent}.encode(ss,ob);
    return ss.str();
}

#ifndef XSON_JSON_HIDE_IOSTREAM

inline auto& operator >> (std::istream& is, object& ob)
{
    ob = xson::json::parse(is);
    return is;
}

inline auto& operator << (std::ostream& os, const object& obj)
{
    const auto indent = os.width();
    auto e = xson::json::encoder{indent};
    os.width(0);
    e.encode(os,obj);
    os.width(indent);
    return os;
}

#endif

} // namespace xson::json

